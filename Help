-- ULTRA-OPTIMIZED GEOMETRY DASH BOT v4.0 - AI REASONING EDITION
-- MAJOR IMPROVEMENTS OVER v3.0:
-- ‚ú® NEW: AI Reasoning powered by Claude Sonnet 4.5
-- ‚ú® NEW: Bot thinks out loud in plain English
-- ‚ú® NEW: Click pattern learning - learns successful click sequences
-- ‚ú® NEW: Parts knowledge database with 60+ part patterns
-- ‚ú® NEW: Mode-aware hazard detection (wave sees ALL obstacles)
-- ‚ú® NEW: Automatic mode change detection
-- ‚ú® NEW: Hazard type classification (instant_death vs wave_obstacle)
-- ‚ú® NEW: Jump pad detection (Yellow, Pink, Red, Gravity)
-- ‚ú® NEW: ORB SYSTEM - 9 orb types with buffering support
-- ‚ú® NEW: PATH DETECTION - identifies fake paths (TheoryOfEverything style)
-- ‚ú® NEW: Friendly platform detection - cube can jump from blocks/slopes
-- ‚ú® NEW: Robot mode with variable distance (1-5 grid blocks)
-- ‚ú® NEW: Ball mode with smart gravity flip logic
-- ‚ú® NEW: 30x30 GRID AWARENESS - precise distance calculation
-- ‚ú® NEW: CUBE JUMP DISTANCES - 1 spike: 3u, 2 spikes: 2u, 3-4 spikes: 1u
-- 1. Wave physics fixed - constant velocity, no gravity
-- 2. Wave-specific math calculations for threading obstacles  
-- 3. AGGRESSIVE learning - LR:0.5, Pass reward:15, learns every 3 frames
-- 4. 25 batch learning iterations on death
-- 5. Increased physics values for all modes
-- 6. Math optimizer trusts itself more (70% confidence)
-- 7. Smart distance thresholds (don't react too early!)
-- 8. Mini mode fully supported with separate physics
-- 9. Parts database detection (Pits, Spikes, Blades, Saws, Blocks, Slopes)
-- 10. AI makes intelligent decisions and explains reasoning
--
-- GRID SYSTEM (30x30):
-- ‚Ä¢ 1 grid unit = 30x30
-- ‚Ä¢ Cube: ONE jump clears spikes based on distance:
--   - 1 spike: jump from 3 grid units away
--   - 2 spikes: jump from 2 grid units away  
--   - 3 spikes: jump from 1 grid unit away
--   - 4 spikes: jump from 1 grid unit away (same as 3 spikes)
--   - 5+ spikes: MUST use pad or orb
-- ‚Ä¢ Robot mode: VARIABLE distance based on hold (1-5 grid blocks)
--   - Hold longer = jump farther (separate from cube mechanics)
-- ‚Ä¢ Cube can jump off friendly platforms (Blocks, Slopes)
-- ‚Ä¢ Orbs: Click when near (can buffer 1-1.5 units ahead)
--   - Yellow: small bounce, Pink: medium, Red: large, Black: highest
--   - OrbGravity (blue): flip gravity, OrbGravityGreen: flip gravity (green)
--   - Dash: forward boost, Spider: teleport
-- ‚Ä¢ Path Detection: Bot detects fake paths (impossible obstacles) and chooses safe route
--
-- CUBE JUMPING:
-- ‚Ä¢ ONE jump per click - clears multiple spikes if timed right
-- ‚Ä¢ Distance to first spike determines clearance
-- ‚Ä¢ Cube can use platforms/blocks as launch points
-- ‚Ä¢ Orbs provide boost or special abilities - can buffer clicks early
-- ‚Ä¢ Multi-path scenarios: bot identifies and avoids fake paths
--
-- MODE MECHANICS:
-- ‚Ä¢ CUBE: Tap to jump - one jump clears 1-3 spikes based on distance
-- ‚Ä¢ SHIP: Spam click to fly (hold = fast up, release = fall, click rapidly = controlled flight)
-- ‚Ä¢ BALL: Gravity flip on click (ground -> ceiling -> ground) - DON'T SPAM!
-- ‚Ä¢ UFO: Click to jump mid-air (like Flappy Bird, can jump in sky)
-- ‚Ä¢ WAVE (dart): Hold = up 45¬∞, Release = down 45¬∞ (smooth diagonal movement)
-- ‚Ä¢ ROBOT: HOLD to jump - hold duration controls distance (1-5 grid blocks)
--   - Quick tap: 1 block, Short: 2 blocks, Medium: 3 blocks, Long: 4 blocks, Max: 5 blocks
--
-- JUMP PADS:
-- ‚Ä¢ PadYellow: 1.5x boost (helps clear 4+ spikes)
-- ‚Ä¢ PadPink: 1.0x normal jump velocity
-- ‚Ä¢ PadRed: 2.0x biggest boost
-- ‚Ä¢ PadGravity: Flips gravity (ground -> ceiling)
--
-- Single file, production ready, uses Roblox player module mechanics + Claude AI

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local p = Players.LocalPlayer
local allowed = { Hitmeforgamepass = true, Pghlego194827 = true }
if not allowed[p.Name] then p:Kick("Unauthorized user.") return end

local lvl = workspace:WaitForChild("Level")
local imm = lvl:WaitForChild("Immutable")
local plr = imm:WaitForChild("Player")
local objs = lvl:WaitForChild("GameObjects")

-- ============================================================================
-- PARTS KNOWLEDGE DATABASE (from level decompilation)
-- ============================================================================
local PARTS_DB = {
    -- Parts that INSTANTLY KILL on contact (any game mode)
    InstantDeath = {
        "WavyPit", "ThornPit", "JaggedPit", "SerratedPit", "CurvedPit", "Pit",
        "RegularSpike", "IceSpike", "InvisSpike", "FakeSpike",
        "LightBlade", "PointyBlade", "SpinBlade", "InvisibleBlade", "RegularBlade", "BlackBlade", "BladeTrap",
        "RegularSaw", "BlackCogwheel"
    },
    
    -- Parts WAVE must avoid (solid obstacles)
    -- Other modes can jump on these, but wave crashes into them
    DangerToWave = {
        "BrickBlock", "BlackBlock", "TileBlock", "GridBlock", "RegularBlock",
        "TileSlope", "ChippedSlope", "BlackSlope", "GridSlope", "ChippedWhiteSlope",
        "WavyStep", "RegularStep"
    },
    
    -- Friendly platforms cube can jump FROM
    Friendly = {
        "BrickBlock", "BlackBlock", "TileBlock", "GridBlock", "RegularBlock",
        "TileSlope", "ChippedSlope", "BlackSlope", "GridSlope", "ChippedWhiteSlope",
        "WavyStep", "RegularStep"
    },
    
    Orbs = {
        OrbYellow = {name = "OrbYellow", boost = 1.0, type = "jump", description = "Small upward bounce"},
        OrbPink = {name = "OrbPink", boost = 1.2, type = "jump", description = "Medium upward bounce"},
        OrbRed = {name = "OrbRed", boost = 1.5, type = "jump", description = "Large upward bounce"},
        OrbBlack = {name = "OrbBlack", boost = 2.0, type = "jump", description = "Very large upward bounce (highest)"},
        OrbDash = {name = "OrbDash", boost = 1.3, type = "dash", description = "Propels player forward rapidly"},
        OrbGravity = {name = "OrbGravity", boost = 0, type = "gravity", description = "BLUE ORB - Flips gravity (ground to ceiling or vice versa)"},
        OrbGravityGreen = {name = "OrbGravityGreen", boost = 0, type = "gravity", description = "GREEN GRAVITY ORB - Flips gravity (green variant)"},
        OrbDashGravity = {name = "OrbDashGravity", boost = 1.3, type = "dash_gravity", description = "Dash forward AND flip gravity"},
        OrbSpider = {name = "OrbSpider", boost = 0, type = "teleport", description = "Teleports to opposite surface (ceiling/floor)"}
    }
}

-- Create fast lookup sets
local INSTANT_DEATH_SET = {}
for _, pattern in ipairs(PARTS_DB.InstantDeath) do
    INSTANT_DEATH_SET[pattern] = true
end

local DANGER_TO_WAVE_SET = {}
for _, pattern in ipairs(PARTS_DB.DangerToWave) do
    DANGER_TO_WAVE_SET[pattern] = true
end

local FRIENDLY_SET = {}
for _, pattern in ipairs(PARTS_DB.Friendly) do
    FRIENDLY_SET[pattern] = true
end

-- Helper: Check if name matches any pattern in set
local function matchesPattern(name, patternSet)
    for pattern in pairs(patternSet) do
        if name:find(pattern) then
            return true
        end
    end
    return false
end

local function findPlatformBelowCube(px, py)
    for _, obj in pairs(objs:GetDescendants()) do
        if obj:IsA("BasePart") then
            local objName = obj.Name
            local parentName = obj.Parent and obj.Parent.Name or ""
            
            if matchesPattern(objName, FRIENDLY_SET) or matchesPattern(parentName, FRIENDLY_SET) then
                local dx = math.abs(obj.Position.X - px)
                local dy = py - obj.Position.Y
                
                if dx < 1.5 and dy > 0 and dy < (obj.Size.Y / 2 + 1.0) then
                    return obj
                end
            end
        end
    end
    return nil
end

-- ============================================================================
-- CLICK PATTERN LEARNING SYSTEM
-- ============================================================================
local CLICK_PATTERNS = {
    successful = {}, -- Patterns that led to survival
    failed = {}, -- Patterns that led to death
    current = {}, -- Current pattern being recorded
    lastClick = 0,
    lastRelease = 0
}

local function recordClick(action, frame)
    table.insert(CLICK_PATTERNS.current, {
        action = action, -- 0 = release, 1 = hold
        frame = frame,
        time = tick()
    })
    
    -- Keep pattern size manageable
    if #CLICK_PATTERNS.current > 50 then
        table.remove(CLICK_PATTERNS.current, 1)
    end
end

local function saveSuccessfulPattern()
    if #CLICK_PATTERNS.current > 5 then
        -- Extract timing patterns
        local pattern = {
            clicks = {},
            totalDuration = 0,
            avgClickDuration = 0,
            avgReleaseDuration = 0
        }
        
        local clickDurations = {}
        local releaseDurations = {}
        local lastActionFrame = 0
        local lastAction = 0
        
        for i, click in ipairs(CLICK_PATTERNS.current) do
            if i > 1 then
                local duration = click.frame - lastActionFrame
                if lastAction == 1 then
                    table.insert(clickDurations, duration)
                else
                    table.insert(releaseDurations, duration)
                end
            end
            lastActionFrame = click.frame
            lastAction = click.action
            table.insert(pattern.clicks, click.action)
        end
        
        -- Calculate averages
        if #clickDurations > 0 then
            local sum = 0
            for _, d in ipairs(clickDurations) do sum = sum + d end
            pattern.avgClickDuration = sum / #clickDurations
        end
        
        if #releaseDurations > 0 then
            local sum = 0
            for _, d in ipairs(releaseDurations) do sum = sum + d end
            pattern.avgReleaseDuration = sum / #releaseDurations
        end
        
        pattern.totalDuration = CLICK_PATTERNS.current[#CLICK_PATTERNS.current].frame - CLICK_PATTERNS.current[1].frame
        pattern.score = 1.0
        
        table.insert(CLICK_PATTERNS.successful, pattern)
        
        -- Keep only best 100 patterns
        if #CLICK_PATTERNS.successful > 100 then
            table.sort(CLICK_PATTERNS.successful, function(a, b) return a.score > b.score end)
            table.remove(CLICK_PATTERNS.successful, #CLICK_PATTERNS.successful)
        end
    end
end

local function saveFailedPattern()
    if #CLICK_PATTERNS.current > 3 then
        table.insert(CLICK_PATTERNS.failed, {
            clicks = {},
            lastActions = {}
        })
        
        -- Record last 10 actions before death
        local start = math.max(1, #CLICK_PATTERNS.current - 10)
        for i = start, #CLICK_PATTERNS.current do
            table.insert(CLICK_PATTERNS.failed[#CLICK_PATTERNS.failed].lastActions, CLICK_PATTERNS.current[i].action)
        end
        
        -- Keep only last 50 failed patterns
        if #CLICK_PATTERNS.failed > 50 then
            table.remove(CLICK_PATTERNS.failed, 1)
        end
    end
end

local function getSuggestedAction(frame, lastAction)
    -- If we have successful patterns, use them
    if #CLICK_PATTERNS.successful > 5 then
        -- Find patterns that match recent behavior
        local recentActions = {}
        local lookback = math.min(5, #CLICK_PATTERNS.current)
        for i = #CLICK_PATTERNS.current - lookback + 1, #CLICK_PATTERNS.current do
            if CLICK_PATTERNS.current[i] then
                table.insert(recentActions, CLICK_PATTERNS.current[i].action)
            end
        end
        
        -- Find best matching pattern
        local bestMatch = nil
        local bestScore = 0
        
        for _, pattern in ipairs(CLICK_PATTERNS.successful) do
            if #pattern.clicks >= #recentActions then
                local matches = 0
                for i = 1, #recentActions do
                    if pattern.clicks[#pattern.clicks - #recentActions + i] == recentActions[i] then
                        matches = matches + 1
                    end
                end
                local score = matches / #recentActions * pattern.score
                if score > bestScore then
                    bestScore = score
                    bestMatch = pattern
                end
            end
        end
        
        -- Use pattern if confident enough
        if bestMatch and bestScore > 0.6 then
            local nextIndex = #recentActions + 1
            if nextIndex <= #bestMatch.clicks then
                return bestMatch.clicks[nextIndex], bestScore, "pattern"
            end
        end
    end
    
    -- Check if recent actions led to failure
    if #CLICK_PATTERNS.failed > 0 then
        local recentActions = {}
        local lookback = math.min(3, #CLICK_PATTERNS.current)
        for i = #CLICK_PATTERNS.current - lookback + 1, #CLICK_PATTERNS.current do
            if CLICK_PATTERNS.current[i] then
                table.insert(recentActions, CLICK_PATTERNS.current[i].action)
            end
        end
        
        -- Check if this matches a failed pattern
        for _, failedPattern in ipairs(CLICK_PATTERNS.failed) do
            local matches = 0
            if #failedPattern.lastActions >= #recentActions then
                for i = 1, #recentActions do
                    if failedPattern.lastActions[i] == recentActions[i] then
                        matches = matches + 1
                    end
                end
                if matches == #recentActions then
                    -- Avoid repeating failed pattern
                    return 1 - lastAction, 0.8, "avoid_failure"
                end
            end
        end
    end
    
    return nil, 0, "none"
end

-- ============================================================================
-- AI REASONING SYSTEM (Claude Sonnet 4.5)
-- ============================================================================
local HttpService = game:GetService("HttpService")

local AI_BRAIN = {
    enabled = true,
    lastThought = "",
    lastDecision = 0,
    decisionCache = {}, -- Cache recent decisions to avoid spam
    thinkInterval = 5, -- Think every N frames when uncertain
    lastThinkFrame = 0,
    thoughts = {}, -- Recent thoughts for debugging
    maxThoughts = 20
}

local function askAI(gameState)
    -- Build mode-specific context
    local modeContext = ""
    if gameState.mode == "wave" then
        modeContext = [[

‚ö†Ô∏è WAVE MODE PHYSICS:
- Wave moves at constant 45¬∞ angle (diagonal)
- Holding (1) = move UP diagonally
- Releasing (0) = move DOWN diagonally
- Make SMOOTH corrections - don't oscillate
- Only change direction when necessary (obstacles or bounds)
- Think ahead: where will I be in 0.5 seconds?
- PATH AWARE: If multiple paths detected, navigate to safe path Y-range]]
    elseif gameState.mode == "robot" then
        modeContext = [[

‚ö†Ô∏è ROBOT MODE PHYSICS:
- HOLD to jump - longer hold = higher/farther jump
- Variable distance based on hold duration:
  * Quick tap (5 frames): ~1 grid block
  * Short hold (8 frames): ~2 grid blocks
  * Medium hold (11 frames): ~3 grid blocks
  * Long hold (14 frames): ~4 grid blocks
  * Max hold (18 frames): ~5 grid blocks
- Calculate required distance and hold accordingly
- COMPLETELY SEPARATE from cube jump mechanics
- PATH AWARE: Navigate to safe path if multiple paths detected

ORB MECHANICS (click when near):
  * Yellow: Small bounce, Pink: Medium, Red: Large, Black: Highest
  * Blue Gravity Orb (OrbGravity): Flips gravity
  * Green Gravity Orb: Flips gravity (green variant)
  * Dash: Forward boost
  * Dash+Gravity: Dash AND flip gravity
  * Spider: Teleport to opposite surface]]
    elseif gameState.mode == "ball" then
        modeContext = [[

‚ö†Ô∏è BALL MODE PHYSICS:
- Click to FLIP gravity (ground ‚Üî ceiling)
- Don't spam - needs time to flip
- Only flip when necessary to avoid obstacles
- Think: will I hit something if I don't flip?
- PATH AWARE: Navigate to safe path if multiple paths detected

ORB MECHANICS (click when near):
  * Yellow: Small bounce, Pink: Medium, Red: Large, Black: Highest
  * Blue Gravity Orb (OrbGravity): Flips gravity
  * Green Gravity Orb: Flips gravity (green variant)
  * Dash: Forward boost
  * Dash+Gravity: Dash AND flip gravity
  * Spider: Teleport to opposite surface]]
    elseif gameState.mode == "ship" then
        modeContext = [[

‚ö†Ô∏è SHIP MODE PHYSICS:
- HOLD to fly up, RELEASE to fall
- Spam click for controlled flight
- Fast upward acceleration when holding
- Gravity pulls down when released
- PATH AWARE: Navigate to safe path if multiple paths detected

ORB MECHANICS (click when near):
  * Yellow: Small bounce, Pink: Medium, Red: Large, Black: Highest
  * Blue Gravity Orb (OrbGravity): Flips gravity
  * Green Gravity Orb: Flips gravity (green variant)
  * Dash: Forward boost
  * Dash+Gravity: Dash AND flip gravity
  * Spider: Teleport to opposite surface]]
    elseif gameState.mode == "ufo" then
        modeContext = [[

‚ö†Ô∏è UFO MODE PHYSICS:
- Click to jump mid-air (like Flappy Bird)
- Can jump while already in the air
- Multiple jumps possible
- Each click gives upward boost
- PATH AWARE: Navigate to safe path if multiple paths detected

ORB MECHANICS (click when near):
  * Yellow: Small bounce, Pink: Medium, Red: Large, Black: Highest
  * Blue Gravity Orb (OrbGravity): Flips gravity
  * Green Gravity Orb: Flips gravity (green variant)
  * Dash: Forward boost
  * Dash+Gravity: Dash AND flip gravity
  * Spider: Teleport to opposite surface]]
    elseif gameState.mode == "cube" then
        modeContext = [[

‚ö†Ô∏è CUBE MODE PHYSICS:
- Simple tap to jump - ONE jump clears spikes
- Jump distance determines how many spikes cleared:
  * 1 spike: Jump when 3 grid units away
  * 2 spikes: Jump when 2 grid units away
  * 3 spikes: Jump when 1 grid unit away
  * 4 spikes: Jump when 1 grid unit away (same as 3)
  * 5+ spikes: MUST use pad or orb
- Can jump from ground or friendly platforms (Blocks, Slopes)
- Grid is 30x30 units

ORB MECHANICS (click when near, can buffer 1-1.5 units ahead):
  * Yellow Orb: Small upward bounce
  * Pink Orb: Medium upward bounce
  * Red Orb: Large upward bounce
  * Black Orb: Very large upward bounce (highest jump)
  * Blue Gravity Orb (OrbGravity): Flips gravity (ground‚Üîceiling)
  * Green Gravity Orb (OrbGravityGreen): Flips gravity (green variant)
  * Dash Orb: Propels forward rapidly
  * Dash+Gravity Orb: Dash forward AND flip gravity
  * Spider Orb: Teleports to opposite surface

PATH DETECTION:
- In multi-path scenarios (like TheoryOfEverything), detect fake paths
- Fake paths have impossible obstacles (5+ spikes with no pad/orb)
- Choose the safe path with lowest threat level
- Navigate to recommended path Y-range]]
    end
    
    -- Build context for AI
    local context = string.format([[You are controlling a Geometry Dash bot. Make a decision: JUMP (1) or STAY (0).

CURRENT SITUATION:
- Game Mode: %s%s
- Position: X=%.1f, Y=%.1f
- Velocity: X=%.1f, Y=%.1f
- Deaths: %d, Passes: %d%s

NEARBY HAZARDS (next 5):
%s%s%s%s%s

DECISION REQUIRED:
Respond in this EXACT format:
ACTION: [0 or 1]
REASONING: [one sentence explaining why]

Be decisive and smart. Consider physics and timing.]], 
        gameState.mode,
        gameState.mini and " (MINI)" or "",
        gameState.px, gameState.py,
        gameState.vx, gameState.vy,
        gameState.deaths, gameState.passes,
        modeContext,
        gameState.hazards or "None in range",
        gameState.pads or "",
        gameState.orbs or "",
        gameState.spikes or "",
        gameState.paths or ""
    )
    
    local success, result = pcall(function()
        local requestBody = HttpService:JSONEncode({
            model = "claude-sonnet-4-20250514",
            max_tokens = 150,
            messages = {{
                role = "user",
                content = context
            }}
        })
        
        local headers = {
            ["Content-Type"] = "application/json",
            ["anthropic-version"] = "2023-06-01"
        }
        
        local response = HttpService:RequestAsync({
            Url = "https://api.anthropic.com/v1/messages",
            Method = "POST",
            Headers = headers,
            Body = requestBody
        })
        
        if response.Success then
            return HttpService:JSONDecode(response.Body)
        else
            return nil
        end
    end)
    
    if success and result and result.content and result.content[1] then
        local text = result.content[1].text
        
        -- Parse response
        local action = text:match("ACTION:%s*(%d)")
        local reasoning = text:match("REASONING:%s*(.+)")
        
        if action and reasoning then
            return tonumber(action), reasoning:gsub("\n", " "):sub(1, 100)
        end
    end
    
    return nil, nil
end

local function getAIDecision(f, isMini)
    -- Safety check: ensure STATE and AI_BRAIN are initialized
    if not STATE or not AI_BRAIN then
        return nil, nil, "not_initialized"
    end
    
    -- Don't spam AI calls
    if STATE.frame - AI_BRAIN.lastThinkFrame < AI_BRAIN.thinkInterval then
        return nil, nil, "ai_cooldown"
    end
    
    -- Build hazard description
    local hazardDesc = ""
    local hazardCount = 0
    for _, h in ipairs(STATE.hazards) do
        if h.p and h.p.Parent then
            local dx = h.pos.X - f.px
            if dx > 0 and dx < 10 and hazardCount < 5 then
                hazardCount = hazardCount + 1
                hazardDesc = hazardDesc .. string.format("\n  %d. %s at X=%.1f Y=%.1f (%.1f units away, threat:%.1f)",
                    hazardCount, h.name, h.pos.X, h.pos.Y, dx, h.t)
            end
        end
    end
    
    if hazardDesc == "" then
        hazardDesc = "None in immediate range"
    end
    
    -- Build pad description
    local padDesc = ""
    if f.nearestPad then
        padDesc = string.format("\nüéØ JUMP PAD: %s at %.1f units ahead (boost: %.1fx)", 
            f.nearestPad.padType, f.padDist, f.nearestPad.boost)
    end
    
    local orbDesc = ""
    if f.nearestOrb then
        orbDesc = string.format("\nüíé ORB: %s (%s) at %.1f units ahead - click when touching!", 
            f.nearestOrb.name, f.nearestOrb.orbType, f.orbDist)
    end
    
    -- Build multi-spike info
    local spikeInfo = ""
    if f.multiJumpPlan then
        local plan = f.multiJumpPlan
        spikeInfo = string.format("\n‚ö†Ô∏è SPIKE GROUP: %d consecutive spikes detected! Strategy: %s", 
            plan.spikeCount, plan.strategy)
        if plan.spikeCount >= 3 then
            spikeInfo = spikeInfo .. "\n   üî• IMPORTANT: Need " .. plan.spikeCount .. " separate jumps!"
        end
    end
    
    local pathInfo = ""
    if f.pathInfo and f.pathInfo.hasFakePath then
        pathInfo = string.format("\nüõ§Ô∏è PATH CHOICE DETECTED: %d paths found", #f.pathInfo.detectedPaths)
        if f.pathInfo.recommendedPath then
            pathInfo = pathInfo .. string.format("\n   ‚úÖ SAFE PATH: %s (Y: %.1f-%.1f, threat: %.1f)", 
                f.pathInfo.recommendedPath.name, 
                f.pathInfo.recommendedPath.yMin, 
                f.pathInfo.recommendedPath.yMax,
                f.pathInfo.recommendedPath.totalThreat)
        end
        for _, path in ipairs(f.pathInfo.detectedPaths) do
            if path.impossible then
                pathInfo = pathInfo .. string.format("\n   ‚ùå FAKE PATH: %s (impossible obstacles!)", path.name)
            end
        end
    end
    
    local gameState = {
        mode = STATE.mode,
        mini = isMini,
        px = f.px,
        py = f.py,
        vx = f.vx,
        vy = f.vy,
        deaths = STATE.deaths,
        passes = STATE.passes,
        hazards = hazardDesc,
        pads = padDesc,
        orbs = orbDesc,
        spikes = spikeInfo,
        paths = pathInfo
    }
    
    -- Ask AI
    local action, reasoning = askAI(gameState)
    
    if action and reasoning then
        AI_BRAIN.lastThought = reasoning
        AI_BRAIN.lastDecision = action
        AI_BRAIN.lastThinkFrame = STATE.frame
        
        -- Store thought
        table.insert(AI_BRAIN.thoughts, {
            frame = STATE.frame,
            thought = reasoning,
            action = action
        })
        if #AI_BRAIN.thoughts > AI_BRAIN.maxThoughts then
            table.remove(AI_BRAIN.thoughts, 1)
        end
        
        -- Print what AI is thinking
        local actionText = action == 1 and "JUMP" or "STAY"
        print(string.format("üß† AI: [%s] %s", actionText, reasoning))
        
        return action, 0.95, "ai_reasoning"
    end
    
    return nil, nil, "ai_failed"
end

-- ============================================================================
-- CONFIG
-- ============================================================================
local CFG = {
    LR = 0.5, -- MUCH higher learning rate
    GAMMA = 0.98,
    EPS = 0.6, -- MORE exploration
    EPS_MIN = 0.02,
    EPS_DECAY = 0.9988, -- slower decay for more exploration
    
    REPLAY_SIZE = 4000, -- bigger buffer
    BATCH = 80, -- larger batches
    LOOKAHEAD = 20, -- see further ahead
    MAX_HAZARDS = 15,
    
    R_ALIVE = 0.25, -- bigger alive reward
    R_PASS = 15.0, -- MUCH bigger pass reward
    R_DEATH = -6.0, -- less harsh death
    R_CLOSE = 3.0, -- bigger close call reward
    R_PROGRESS = 0.5, -- bigger progress reward
    
    FRAME_SKIP = 1,
    GRID_SIZE = 30,
    
    ROBOT_JUMP_MAP = {
        [1] = 5,
        [2] = 8,
        [3] = 11,
        [4] = 14,
        [5] = 18
    }
}

-- ============================================================================
-- STATE
-- ============================================================================
local STATE = {
    alive = true,
    mode = "cube",
    mini = false, -- mini mode
    eps = CFG.EPS,
    frame = 0,
    deaths = 0,
    passes = 0,
    totalR = 0,
    
    q = {}, -- Q-table
    replay = {}, -- experience replay
    hazards = {},
    pads = {},
    orbs = {},
    passed = {},
    
    lastS = nil,
    lastA = nil,
    lastF = nil,
    
    maxX = 0, -- track furthest progress
    lastX = 0, -- for progress reward
    
    -- WAVE MODE SMOOTHING (adaptive cooldown)
    waveHoldState = 0, -- 0 = releasing, 1 = holding
    waveLastDecisionFrame = 0, -- last frame we made a wave decision
    lastMethod = "unknown", -- track decision method
    
    -- ROBOT MODE (hold to jump mechanics)
    robotHoldStart = 0, -- frame when hold started
    robotIsHolding = false, -- currently holding
    robotTargetHoldDuration = 5, -- frames to hold (calculated based on distance needed)
    
    -- BALL MODE (gravity flip mechanics)
    ballLastFlipFrame = 0, -- last frame we flipped gravity
    
    -- CUBE MODE (prevent spam jumping)
    cubeLastJumpFrame = 0, -- last frame we jumped
    
    -- MULTI-SPIKE JUMP PLANNING
    multiJumpPlan = {}, -- planned jumps for consecutive spikes
    multiJumpIndex = 0 -- current index in plan
}

-- ============================================================================
-- HAZARD SCANNER (uses parts database for accurate detection)
-- ============================================================================
local function scanHazards()
    local h = {}
    local mode = STATE.mode
    
    for _, obj in pairs(objs:GetDescendants()) do
        if obj:IsA("BasePart") then
            local isHazard = false
            local threat = 1.0
            local hazardType = "unknown"
            
            local objName = obj.Name
            local parentName = obj.Parent and obj.Parent.Name or ""
            
            -- Skip standalone Hitbox parts (they're children of actual hazards)
            local skipHitbox = objName == "Hitbox" and not matchesPattern(parentName, INSTANT_DEATH_SET) 
               and not matchesPattern(parentName, DANGER_TO_WAVE_SET)
            
            if not skipHitbox then
                -- Check against InstantDeath database (kills all modes)
                if matchesPattern(objName, INSTANT_DEATH_SET) or matchesPattern(parentName, INSTANT_DEATH_SET) then
                    isHazard = true
                    hazardType = "instant_death"
                    threat = 2.0
                    
                    -- Extra threat for specific types
                    if objName:find("Saw") or objName:find("Blade") then
                        threat = 2.5
                    elseif objName:find("Pit") then
                        threat = 3.0  -- Pits are very dangerous
                    end
                end
                
                -- Check against DangerToWave database
                -- WAVE must avoid ALL solid blocks/slopes/steps
                if mode == "wave" then
                    if matchesPattern(objName, DANGER_TO_WAVE_SET) or matchesPattern(parentName, DANGER_TO_WAVE_SET) then
                        isHazard = true
                        hazardType = "wave_obstacle"
                        threat = 1.5  -- Important for wave to avoid
                        
                        -- Slopes are especially tricky for wave
                        if objName:find("Slope") then
                            threat = 2.0
                        end
                    end
                end
                
                -- Fallback: Color-based detection for unknown hazards
                if not isHazard then
                    if obj.BrickColor == BrickColor.new("Really black") then
                        isHazard = true
                        hazardType = "color_dark"
                        threat = 1.2
                    end
                    
                    local c = obj.Color
                    local r, g, b = c.R * 255, c.G * 255, c.B * 255
                    if r < 25 and g < 25 and b < 25 and (r > 10 or g > 10 or b > 10) then
                        isHazard = true
                        hazardType = "color_dark"
                        threat = 1.2
                    end
                end
                
                if isHazard then
                    table.insert(h, {
                        p = obj,
                        pos = obj.Position,
                        sz = obj.Size,
                        t = threat,
                        name = objName,
                        htype = hazardType
                    })
                end
            end
        end
    end
    
    table.sort(h, function(a,b) return a.pos.X < b.pos.X end)
    return h
end

-- ============================================================================
-- PAD SCANNER (detects jump pads and gravity pads)
-- ============================================================================
local function scanPads()
    local pads = {}
    
    for _, obj in pairs(objs:GetDescendants()) do
        if obj:IsA("BasePart") then
            local objName = obj.Name
            local padType = nil
            local boost = 0
            
            -- Detect pad types
            if objName == "PadYellow" then
                padType = "yellow"
                boost = 1.5 -- Medium boost (helps jump 4 spikes)
            elseif objName == "PadPink" then
                padType = "pink"
                boost = 1.0 -- Normal jump velocity
            elseif objName == "PadRed" then
                padType = "red"
                boost = 2.0 -- Biggest boost
            elseif objName == "PadGravity" then
                padType = "gravity"
                boost = 0 -- Changes gravity direction
            end
            
            if padType then
                table.insert(pads, {
                    p = obj,
                    pos = obj.Position,
                    sz = obj.Size,
                    padType = padType,
                    boost = boost,
                    name = objName
                })
            end
        end
    end
    
    table.sort(pads, function(a,b) return a.pos.X < b.pos.X end)
    return pads
end

local function scanOrbs()
    local orbs = {}
    
    for _, obj in pairs(objs:GetDescendants()) do
        if obj:IsA("BasePart") then
            local objName = obj.Name
            local orbInfo = PARTS_DB.Orbs[objName]
            
            if orbInfo then
                table.insert(orbs, {
                    p = obj,
                    pos = obj.Position,
                    sz = obj.Size,
                    orbType = orbInfo.type,
                    boost = orbInfo.boost,
                    name = objName
                })
            end
        end
    end
    
    table.sort(orbs, function(a,b) return a.pos.X < b.pos.X end)
    return orbs
end

-- ============================================================================
-- MINI MODE DETECTOR
-- ============================================================================
local function detectMiniMode()
    -- Check player size - mini mode makes player ~50% smaller
    if plr.Size.Y < 1.5 then
        return true
    end
    
    -- Check for mini portal nearby or mini attribute
    if plr:FindFirstChild("Mini") then
        return plr.Mini.Value
    end
    
    -- Check parent for mini indicator
    if plr.Parent and plr.Parent.Name:lower():find("mini") then
        return true
    end
    
    return false
end

-- ============================================================================
-- MODE DETECTOR (cube, ship, ball, ufo, wave, robot, spider)
-- Detects mode by checking SurfaceGui.Player visibility
-- Mode mapping: dart‚Üíwave, bird‚Üíufo
-- ============================================================================
local function detectMode()
    -- Check the SurfaceGui for visible mode indicator
    local surfaceGui = plr:FindFirstChild("SurfaceGui")
    if surfaceGui then
        local playerGui = surfaceGui:FindFirstChild("Player")
        if playerGui then
            -- Check each mode's visibility
            -- dart = wave, bird = ufo
            if playerGui:FindFirstChild("dart") and playerGui.dart.Visible then 
                return "wave" 
            end
            if playerGui:FindFirstChild("ship") and playerGui.ship.Visible then 
                return "ship" 
            end
            if playerGui:FindFirstChild("ball") and playerGui.ball.Visible then 
                return "ball" 
            end
            if playerGui:FindFirstChild("bird") and playerGui.bird.Visible then 
                return "ufo" 
            end
            if playerGui:FindFirstChild("robot") and playerGui.robot.Visible then 
                return "robot" 
            end
            if playerGui:FindFirstChild("cube") and playerGui.cube.Visible then 
                return "cube" 
            end
        end
    end
    
    -- Fallback: Check for mode attribute
    if plr:FindFirstChild("Mode") then
        local mode = plr.Mode.Value:lower()
        -- Map dart to wave, bird to ufo
        if mode == "dart" then return "wave" end
        if mode == "bird" then return "ufo" end
        return mode
    end
    
    -- Default to cube if can't detect
    return "cube"
end

-- ============================================================================
-- MATHEMATICAL JUMP OPTIMIZER
-- ============================================================================
local function calculateOptimalJump(px, py, vx, vy, hazard, mode, isMini)
    -- Calculate time to reach obstacle
    local dx = hazard.pos.X - px
    if dx <= 0 or vx <= 0 then return nil end
    
    local timeToImpact = dx / vx
    
    -- Get correct physics for mode and mini state
    local jumpPower, gravity = getPhysics(mode, 1, isMini)
    
    -- Current trajectory: y(t) = py + vy*t - 0.5*g*t^2
    local g = gravity
    local predictedY = py + vy * timeToImpact - 0.5 * g * timeToImpact * timeToImpact
    
    -- Obstacle boundaries
    local obstacleTop = hazard.pos.Y + hazard.sz.Y / 2
    local obstacleBottom = hazard.pos.Y - hazard.sz.Y / 2
    
    -- Calculate if we'll collide without jumping
    local playerRadius = isMini and 0.35 or 0.5 -- smaller hitbox in mini mode
    local willCollide = predictedY > (obstacleBottom - playerRadius) and 
                        predictedY < (obstacleTop + playerRadius) and
                        dx < (hazard.sz.X / 2 + playerRadius)
    
    if not willCollide then
        -- No action needed, we'll clear it
        return {action = 0, confidence = 0.9, reason = "natural_clear"}
    end
    
    -- Calculate jump needed
    if mode == "cube" then
        -- Parabolic jump: need to find if jump clears obstacle
        local jumpV0 = jumpPower
        local peakHeight = (jumpV0 * jumpV0) / (2 * g)
        local jumpPeakTime = jumpV0 / g
        
        -- Time when we'll be at obstacle X position
        local timeAtObstacle = dx / vx
        
        -- If we jump now, where will we be at obstacle?
        local jumpY = py + jumpV0 * timeAtObstacle - 0.5 * g * timeAtObstacle * timeAtObstacle
        
        -- Check clearance (mini mode needs less clearance)
        local clearance = jumpY - obstacleTop
        local minClearance = isMini and 0.2 or 0.3
        
        if clearance > minClearance then
            return {action = 1, confidence = 0.95, reason = "math_jump_clear", clearance = clearance}
        elseif clearance > -0.5 then
            return {action = 1, confidence = 0.7, reason = "math_jump_tight", clearance = clearance}
        else
            -- Jump won't clear, maybe duck?
            return {action = 0, confidence = 0.6, reason = "math_duck", clearance = clearance}
        end
        
    elseif mode == "ship" or mode == "wave" then
        -- Wave/Ship: calculate if we can thread through
        local targetY = (obstacleTop + obstacleBottom) / 2
        local currentRelativeY = py - targetY
        
        if mode == "wave" then
            -- Wave needs to position itself carefully
            local waveVel = isMini and PHYS.mini_wave_up or PHYS.wave_up
            local timeToObstacle = timeToImpact
            
            -- Calculate where we'll be if we hold up
            local upY = py + waveVel * timeToObstacle
            -- Calculate where we'll be if we go down
            local downY = py + (isMini and PHYS.mini_wave_down or PHYS.wave_down) * timeToObstacle
            
            -- Check which action gets us closer to safe passage
            local upClearTop = upY - obstacleTop
            local upClearBot = obstacleBottom - upY
            local downClearTop = downY - obstacleTop
            local downClearBot = obstacleBottom - downY
            
            -- Want to be in the middle, but if forced to choose:
            if py < targetY - 0.5 then
                -- Below center, go up
                if upClearTop > -0.3 then
                    return {action = 1, confidence = 0.9, reason = "wave_math_up"}
                else
                    return {action = 0, confidence = 0.75, reason = "wave_math_stay_down"}
                end
            elseif py > targetY + 0.5 then
                -- Above center, go down
                if downClearBot > -0.3 then
                    return {action = 0, confidence = 0.9, reason = "wave_math_down"}
                else
                    return {action = 1, confidence = 0.75, reason = "wave_math_stay_up"}
                end
            else
                -- Near center, maintain or adjust slightly
                if math.abs(currentRelativeY) < 0.2 then
                    return {action = py < targetY and 1 or 0, confidence = 0.85, reason = "wave_math_center"}
                else
                    return {action = currentRelativeY < 0 and 1 or 0, confidence = 0.8, reason = "wave_math_adjust"}
                end
            end
        else
            -- Ship logic
            if py < targetY then
                return {action = 1, confidence = 0.8, reason = "math_ship_up"}
            else
                return {action = 0, confidence = 0.8, reason = "math_ship_down"}
            end
        end
        
    elseif mode == "ufo" then
        -- Similar to cube but different jump velocity
        local jumpV0 = jumpPower
        local timeAtObstacle = dx / vx
        local jumpY = py + jumpV0 * timeAtObstacle - 0.5 * g * timeAtObstacle * timeAtObstacle
        local clearance = jumpY - obstacleTop
        local minClearance = isMini and 0.15 or 0.2
        
        if clearance > minClearance then
            return {action = 1, confidence = 0.9, reason = "math_ufo_jump", clearance = clearance}
        else
            return {action = 0, confidence = 0.6, reason = "math_ufo_wait", clearance = clearance}
        end
    end
    
    return nil
end

-- ============================================================================
-- PHYSICS PREDICTOR (inspired by VR torso tracking from ControlModule)
-- ============================================================================
local PHYS = {
    -- Normal mode
    cube_jump = 28, -- increased
    ship_up = 20, -- increased
    ufo_jump = 26, -- increased
    ball_flip = 24, -- increased
    wave_up = 18, -- wave constant velocity up
    wave_down = -18, -- wave constant velocity down
    grav = 58, -- increased
    
    -- Mini mode (reduced gravity, lower jumps)
    mini_cube_jump = 16,
    mini_ship_up = 13,
    mini_ufo_jump = 15,
    mini_ball_flip = 14,
    mini_wave_up = 11, -- 65% of normal
    mini_wave_down = -11,
    mini_grav = 32
}

local function getPhysics(mode, action, isMini)
    if isMini then
        if mode == "cube" then return PHYS.mini_cube_jump, PHYS.mini_grav
        elseif mode == "ship" then return PHYS.mini_ship_up, PHYS.mini_grav
        elseif mode == "ufo" then return PHYS.mini_ufo_jump, PHYS.mini_grav
        elseif mode == "ball" then return PHYS.mini_ball_flip, PHYS.mini_grav
        elseif mode == "wave" then 
            return action == 1 and PHYS.mini_wave_up or PHYS.mini_wave_down, 0
        end
    else
        if mode == "cube" then return PHYS.cube_jump, PHYS.grav
        elseif mode == "ship" then return PHYS.ship_up, PHYS.grav
        elseif mode == "ufo" then return PHYS.ufo_jump, PHYS.grav
        elseif mode == "ball" then return PHYS.ball_flip, PHYS.grav
        elseif mode == "wave" then 
            return action == 1 and PHYS.wave_up or PHYS.wave_down, 0
        end
    end
    return 20, 50
end

local function predictPath(pos, vel, act, mode, steps, isMini)
    local traj = {}
    local p = Vector3.new(pos.X, pos.Y, pos.Z)
    local v = Vector3.new(vel.X, vel.Y, vel.Z)
    local dt = 0.04
    
    -- Get correct physics values
    local jumpPower, gravity = getPhysics(mode, act, isMini)
    
    for i = 1, steps do
        if mode == "wave" then
            -- Wave: constant velocity based on input, NO gravity
            if act == 1 then
                v = Vector3.new(v.X, isMini and PHYS.mini_wave_up or PHYS.wave_up, v.Z)
            else
                v = Vector3.new(v.X, isMini and PHYS.mini_wave_down or PHYS.wave_down, v.Z)
            end
        elseif act == 1 then
            if mode == "cube" and i == 1 and v.Y <= 1 then
                v = Vector3.new(v.X, jumpPower, v.Z)
            elseif mode == "ship" then
                v = Vector3.new(v.X, jumpPower, v.Z)
            elseif mode == "ufo" and i == 1 then
                v = Vector3.new(v.X, jumpPower, v.Z)
            elseif mode == "ball" and i == 1 then
                v = Vector3.new(v.X, -v.Y * 0.75 + jumpPower, v.Z)
            end
        elseif act == 0 and mode == "ship" then
            local down = jumpPower * -0.65
            v = Vector3.new(v.X, down, v.Z)
        end
        
        -- Apply gravity (except wave)
        if mode ~= "wave" then
            v = Vector3.new(v.X, v.Y - gravity * dt, v.Z)
        end
        
        p = p + v * dt
        table.insert(traj, {p = p, v = v})
    end
    
    return traj
end

local function trajCollides(traj, hazards)
    local playerSize = STATE.mini and 0.35 or 0.5
    for _, point in ipairs(traj) do
        for _, h in ipairs(hazards) do
            if h.p and h.p.Parent then
                local dx = math.abs(point.p.X - h.pos.X)
                local dy = math.abs(point.p.Y - h.pos.Y)
                if dx < (playerSize + h.sz.X/2) and dy < (playerSize + h.sz.Y/2) then
                    return true
                end
            end
        end
    end
    return false
end

-- ============================================================================
-- SPIKE COUNTER (counts consecutive spikes for multi-jump planning)
-- ============================================================================
local function countConsecutiveSpikes(px)
    -- Find groups of spikes that are close together (within 1 unit = consecutive)
    local spikeGroups = {}
    local currentGroup = {}
    
    for _, h in ipairs(STATE.hazards) do
        if h.p and h.p.Parent then
            local dx = h.pos.X - px
            -- Only look ahead
            if dx > 0 and dx < 15 then
                -- Check if it's a spike
                if h.name:find("Spike") or h.name:find("spike") then
                    -- Check if this spike is consecutive with the current group
                    if #currentGroup == 0 then
                        -- Start new group
                        table.insert(currentGroup, h)
                    else
                        -- Check distance from last spike in group
                        local lastSpike = currentGroup[#currentGroup]
                        local spacing = h.pos.X - lastSpike.pos.X
                        
                        if spacing <= 1.2 then
                            -- Consecutive spike! Add to group
                            table.insert(currentGroup, h)
                        else
                            -- Gap found, start new group
                            if #currentGroup > 0 then
                                table.insert(spikeGroups, currentGroup)
                            end
                            currentGroup = {h}
                        end
                    end
                end
            end
        end
    end
    
    -- Add final group
    if #currentGroup > 0 then
        table.insert(spikeGroups, currentGroup)
    end
    
    return spikeGroups
end

local function detectPaths(px)
    local pathRegions = {
        upper = {},
        middle = {},
        lower = {}
    }
    
    for _, h in ipairs(STATE.hazards) do
        if h.p and h.p.Parent then
            local dx = h.pos.X - px
            if dx > 0 and dx < 20 then
                if h.pos.Y > 7 then
                    table.insert(pathRegions.upper, h)
                elseif h.pos.Y > 3 then
                    table.insert(pathRegions.middle, h)
                else
                    table.insert(pathRegions.lower, h)
                end
            end
        end
    end
    
    local paths = {}
    
    local function analyzePathRegion(region, name, yMin, yMax)
        local hazardCount = #region
        local hasImpossibleObstacle = false
        local totalThreat = 0
        
        for _, h in ipairs(region) do
            totalThreat = totalThreat + h.t
            
            if h.htype == "instant_death" then
                local spikeGroups = {}
                local currentGroup = {}
                
                for _, h2 in ipairs(region) do
                    if h2.name:find("Spike") then
                        if #currentGroup == 0 then
                            table.insert(currentGroup, h2)
                        else
                            local lastSpike = currentGroup[#currentGroup]
                            local spacing = h2.pos.X - lastSpike.pos.X
                            if spacing <= 1.2 then
                                table.insert(currentGroup, h2)
                            else
                                if #currentGroup > 0 then
                                    table.insert(spikeGroups, currentGroup)
                                end
                                currentGroup = {h2}
                            end
                        end
                    end
                end
                if #currentGroup > 0 then
                    table.insert(spikeGroups, currentGroup)
                end
                
                for _, group in ipairs(spikeGroups) do
                    if #group > 4 then
                        local hasPadNearby = false
                        for _, pad in ipairs(STATE.pads) do
                            if pad.p and pad.p.Parent then
                                local pdx = math.abs(pad.pos.X - group[1].pos.X)
                                local pdy = math.abs(pad.pos.Y - group[1].pos.Y)
                                if pdx < 3 and pdy < 2 then
                                    hasPadNearby = true
                                    break
                                end
                            end
                        end
                        
                        local hasOrbNearby = false
                        for _, orb in ipairs(STATE.orbs) do
                            if orb.p and orb.p.Parent then
                                local odx = math.abs(orb.pos.X - group[1].pos.X)
                                local ody = math.abs(orb.pos.Y - group[1].pos.Y)
                                if odx < 3 and ody < 2 then
                                    hasOrbNearby = true
                                    break
                                end
                            end
                        end
                        
                        if not hasPadNearby and not hasOrbNearby then
                            hasImpossibleObstacle = true
                        end
                    end
                end
            end
        end
        
        return {
            name = name,
            yMin = yMin,
            yMax = yMax,
            hazardCount = hazardCount,
            totalThreat = totalThreat,
            impossible = hasImpossibleObstacle,
            isFake = hasImpossibleObstacle
        }
    end
    
    if #pathRegions.upper > 0 then
        table.insert(paths, analyzePathRegion(pathRegions.upper, "upper", 7, 10))
    end
    if #pathRegions.middle > 0 then
        table.insert(paths, analyzePathRegion(pathRegions.middle, "middle", 3, 7))
    end
    if #pathRegions.lower > 0 then
        table.insert(paths, analyzePathRegion(pathRegions.lower, "lower", 0, 3))
    end
    
    if #paths <= 1 then
        return nil
    end
    
    local safePaths = {}
    for _, path in ipairs(paths) do
        if not path.impossible then
            table.insert(safePaths, path)
        end
    end
    
    if #safePaths == 0 then
        return nil
    end
    
    table.sort(safePaths, function(a, b)
        return a.totalThreat < b.totalThreat
    end)
    
    return {
        detectedPaths = paths,
        safePaths = safePaths,
        recommendedPath = safePaths[1],
        hasFakePath = #paths > #safePaths
    }
end

-- ============================================================================
-- MULTI-JUMP PLANNER (plans jumps for consecutive spikes)
-- ============================================================================
local function planMultiJump(px)
    local spikeGroups = countConsecutiveSpikes(px)
    
    if #spikeGroups == 0 then
        return nil
    end
    
    local nearestGroup = spikeGroups[1]
    local spikeCount = #nearestGroup
    local firstSpikeX = nearestGroup[1].pos.X
    local distToFirst = firstSpikeX - px
    
    if spikeCount == 1 then
        return {
            spikeCount = 1,
            jumpDistance = 3.0,
            strategy = "single_spike"
        }
    elseif spikeCount == 2 then
        return {
            spikeCount = 2,
            jumpDistance = 2.0,
            strategy = "double_spike"
        }
    elseif spikeCount == 3 then
        return {
            spikeCount = 3,
            jumpDistance = 1.0,
            strategy = "triple_spike"
        }
    elseif spikeCount == 4 then
        local nearestPad = nil
        local minPadDist = 999
        for _, pad in ipairs(STATE.pads) do
            if pad.p and pad.p.Parent then
                local pdx = pad.pos.X - px
                if pdx > 0 and pdx < distToFirst and pdx < minPadDist then
                    minPadDist = pdx
                    nearestPad = pad
                end
            end
        end
        
        local nearestOrb = nil
        local minOrbDist = 999
        for _, orb in ipairs(STATE.orbs) do
            if orb.p and orb.p.Parent and (orb.orbType == "jump" or orb.orbType == "dash") then
                local odx = orb.pos.X - px
                if odx > 0 and odx < distToFirst and odx < minOrbDist then
                    minOrbDist = odx
                    nearestOrb = orb
                end
            end
        end
        
        if nearestPad then
            return {
                spikeCount = 4,
                jumpDistance = minPadDist - 0.5,
                strategy = "use_pad",
                usePad = true
            }
        elseif nearestOrb then
            return {
                spikeCount = 4,
                jumpDistance = minOrbDist - 0.3,
                strategy = "use_orb",
                useOrb = true,
                orb = nearestOrb
            }
        else
            return {
                spikeCount = 4,
                jumpDistance = 1.0,
                strategy = "four_spike_attempt",
                lastFrame = true
            }
        end
    else
        local nearestPad = nil
        local minPadDist = 999
        for _, pad in ipairs(STATE.pads) do
            if pad.p and pad.p.Parent then
                local pdx = pad.pos.X - px
                if pdx > 0 and pdx < distToFirst and pdx < minPadDist then
                    minPadDist = pdx
                    nearestPad = pad
                end
            end
        end
        
        local nearestOrb = nil
        local minOrbDist = 999
        for _, orb in ipairs(STATE.orbs) do
            if orb.p and orb.p.Parent and (orb.orbType == "jump" or orb.orbType == "dash") then
                local odx = orb.pos.X - px
                if odx > 0 and odx < distToFirst and odx < minOrbDist then
                    minOrbDist = odx
                    nearestOrb = orb
                end
            end
        end
        
        if nearestPad then
            return {
                spikeCount = spikeCount,
                jumpDistance = minPadDist - 0.5,
                strategy = "use_pad",
                usePad = true
            }
        elseif nearestOrb then
            return {
                spikeCount = spikeCount,
                jumpDistance = minOrbDist - 0.3,
                strategy = "use_orb",
                useOrb = true,
                orb = nearestOrb
            }
        else
            return {
                spikeCount = spikeCount,
                jumpDistance = 0,
                strategy = "impossible_need_pad",
                impossible = true
            }
        end
    end
end

-- ============================================================================
-- STATE ENCODER (compact, discretized like camera module properties)
-- ============================================================================
local function extractFeats(px, py, vx, vy)
    local f = {
        px = px, py = py, vx = vx, vy = vy,
        obs = {},
        minD = 999,
        avgT = 0,
        nAhead = 0,
        nearestPad = nil, -- nearest pad ahead
        padDist = 999
    }
    
    local cnt = 0
    for _, h in ipairs(STATE.hazards) do
        if cnt >= CFG.MAX_HAZARDS then break end
        if h.p and h.p.Parent then
            local dx = h.pos.X - px
            if dx >= -2 and dx <= 18 then
                cnt = cnt + 1
                local dy = h.pos.Y - py
                local d = math.sqrt(dx*dx + dy*dy)
                
                table.insert(f.obs, {dx=dx, dy=dy, d=d, t=h.t})
                
                if d < f.minD then f.minD = d end
                if dx > 0 then
                    f.nAhead = f.nAhead + 1
                    f.avgT = f.avgT + h.t
                end
            end
        end
    end
    
    -- Check for nearby pads
    for _, pad in ipairs(STATE.pads) do
        if pad.p and pad.p.Parent then
            local dx = pad.pos.X - px
            if dx >= 0 and dx <= 10 then
                local dy = pad.pos.Y - py
                local d = math.sqrt(dx*dx + dy*dy)
                if d < f.padDist then
                    f.padDist = d
                    f.nearestPad = pad
                end
            end
        end
    end
    
    f.nearestOrb = nil
    f.orbDist = 999
    for _, orb in ipairs(STATE.orbs) do
        if orb.p and orb.p.Parent then
            local dx = orb.pos.X - px
            if dx >= 0 and dx <= 10 then
                local dy = orb.pos.Y - py
                local d = math.sqrt(dx*dx + dy*dy)
                if d < f.orbDist then
                    f.orbDist = d
                    f.nearestOrb = orb
                end
            end
        end
    end
    
    if f.nAhead > 0 then
        f.avgT = f.avgT / f.nAhead
    end
    
    if STATE.mode == "cube" or STATE.mode == "ship" or STATE.mode == "ball" then
        f.multiJumpPlan = planMultiJump(px)
    else
        f.multiJumpPlan = nil
    end
    
    f.pathInfo = detectPaths(px)
    
    return f
end

local function stateKey(f, isMini)
    if #f.obs == 0 then 
        return STATE.mode .. (isMini and ":mini" or "") .. ":safe" 
    end
    
    local o = f.obs[1]
    -- Finer discretization for 30x30 grid
    return string.format("%s%s:y%d:vy%d:dx%d:dy%d:d%d:t%d:n%d",
        STATE.mode,
        isMini and ":mini" or "",
        math.floor(f.py / 0.3), -- finer Y buckets
        math.floor(f.vy / 3), -- finer velocity buckets
        math.floor(o.dx / 0.3), -- finer X distance
        math.floor(o.dy / 0.3), -- finer Y distance
        math.floor(o.d / 0.5), -- actual distance to obstacle
        math.floor(f.avgT / 0.2),
        math.min(f.nAhead, 10)
    )
end

-- ============================================================================
-- Q-LEARNING (with experience replay like BaseCharacterController pattern)
-- ============================================================================
local function getQ(s, a)
    if not STATE.q[s] then STATE.q[s] = {[0]=0, [1]=0} end
    return STATE.q[s][a]
end

local function setQ(s, a, v)
    if not STATE.q[s] then STATE.q[s] = {[0]=0, [1]=0} end
    STATE.q[s][a] = v
end

local function getBest(s)
    local q0, q1 = getQ(s, 0), getQ(s, 1)
    return q1 > q0 and 1 or 0
end

local function updateQ(s, a, r, ns, done)
    local curr = getQ(s, a)
    local maxNext = done and 0 or math.max(getQ(ns, 0), getQ(ns, 1))
    local target = r + CFG.GAMMA * maxNext
    setQ(s, a, curr + CFG.LR * (target - curr))
end

local function addReplay(s, a, r, ns, done)
    table.insert(STATE.replay, {s=s, a=a, r=r, ns=ns, done=done})
    if #STATE.replay > CFG.REPLAY_SIZE then
        table.remove(STATE.replay, 1)
    end
end

local function learnBatch()
    if #STATE.replay < CFG.BATCH then return end
    
    for i = 1, CFG.BATCH do
        local idx = math.random(1, #STATE.replay)
        local e = STATE.replay[idx]
        updateQ(e.s, e.a, e.r, e.ns, e.done)
    end
end

-- ============================================================================
-- WAVE MODE SMART DECISION (reduces oscillation with hold-state tracking)
-- ============================================================================
local function decideWave(f, isMini)
    if f.pathInfo and f.pathInfo.hasFakePath then
        local recommended = f.pathInfo.recommendedPath
        if recommended then
            if f.py < recommended.yMin then
                STATE.waveHoldState = 1
                STATE.waveLastDecisionFrame = STATE.frame
                return 1, nil, string.format("wave_path_up_to_%s", recommended.name)
            elseif f.py > recommended.yMax then
                STATE.waveHoldState = 0
                STATE.waveLastDecisionFrame = STATE.frame
                return 0, nil, string.format("wave_path_down_to_%s", recommended.name)
            end
        end
    end
    
    local nearHazard = f.minD < 3
    local cooldown = nearHazard and 5 or 10
    
    local framesSinceLastDecision = STATE.frame - STATE.waveLastDecisionFrame
    
    if framesSinceLastDecision < cooldown then
        return STATE.waveHoldState, nil, "wave_hold_state"
    end
    
    STATE.waveLastDecisionFrame = STATE.frame
    
    local minY = isMini and 1.5 or 2.5
    local maxY = isMini and 6.5 or 8.5
    
    local pos = Vector3.new(f.px, f.py, 0)
    local vel = Vector3.new(f.vx, f.vy, 0)
    
    local traj0 = predictPath(pos, vel, 0, "wave", CFG.LOOKAHEAD * 2, isMini)
    local traj1 = predictPath(pos, vel, 1, "wave", CFG.LOOKAHEAD * 2, isMini)
    
    local collision0 = trajCollides(traj0, STATE.hazards)
    local collision1 = trajCollides(traj1, STATE.hazards)
    
    local outOfBounds0 = false
    local outOfBounds1 = false
    for i = 1, math.min(10, #traj0) do
        if traj0[i].p.Y < minY or traj0[i].p.Y > maxY then outOfBounds0 = true break end
    end
    for i = 1, math.min(10, #traj1) do
        if traj1[i].p.Y < minY or traj1[i].p.Y > maxY then outOfBounds1 = true break end
    end
    
    local newAction
    
    if collision0 and not collision1 then
        newAction = 1
    elseif collision1 and not collision0 then
        newAction = 0
    elseif outOfBounds0 and not outOfBounds1 then
        newAction = 1
    elseif outOfBounds1 and not outOfBounds0 then
        newAction = 0
    elseif f.py < minY + 1 then
        newAction = 1
    elseif f.py > maxY - 1 then
        newAction = 0
    else
        newAction = STATE.waveHoldState
    end
    
    STATE.waveHoldState = newAction
    
    return newAction, nil, string.format("wave_smart (y=%.1f, holding=%d)", f.py, newAction)
end

-- ============================================================================
-- BALL MODE DECISION (gravity flip mechanics)
-- ============================================================================
local function decideBall(f, isMini)
    local framesSinceLastFlip = STATE.frame - (STATE.ballLastFlipFrame or 0)
    
    if framesSinceLastFlip < 8 then
        return 0, nil, "ball_cooldown"
    end
    
    if f.pathInfo and f.pathInfo.hasFakePath then
        local recommended = f.pathInfo.recommendedPath
        if recommended then
            if f.py < recommended.yMin and framesSinceLastFlip >= 8 then
                STATE.ballLastFlipFrame = STATE.frame
                return 1, nil, string.format("ball_path_flip_to_%s", recommended.name)
            elseif f.py > recommended.yMax and framesSinceLastFlip >= 8 then
                STATE.ballLastFlipFrame = STATE.frame
                return 1, nil, string.format("ball_path_flip_to_%s", recommended.name)
            end
        end
    end
    
    local minY = isMini and 1.5 or 2.5
    local maxY = isMini and 6.5 or 8.5
    
    local pos = Vector3.new(f.px, f.py, 0)
    local vel = Vector3.new(f.vx, f.vy, 0)
    
    local traj0 = predictPath(pos, vel, 0, "ball", CFG.LOOKAHEAD, isMini)
    local traj1 = predictPath(pos, vel, 1, "ball", CFG.LOOKAHEAD, isMini)
    
    local collision0 = trajCollides(traj0, STATE.hazards)
    local collision1 = trajCollides(traj1, STATE.hazards)
    
    local shouldFlip = false
    
    if collision0 and not collision1 then
        shouldFlip = true
    elseif collision1 and not collision0 then
        shouldFlip = false
    elseif f.py < minY + 0.5 then
        shouldFlip = true
    elseif f.py > maxY - 0.5 then
        shouldFlip = true
    elseif #f.obs > 0 and f.obs[1].dx < 3 and f.obs[1].dx > 0 then
        if f.obs[1].dy > 1 then
            shouldFlip = true
        elseif f.obs[1].dy < -1 then
            shouldFlip = true
        end
    end
    
    if shouldFlip then
        STATE.ballLastFlipFrame = STATE.frame
        return 1, nil, "ball_flip"
    else
        return 0, nil, "ball_steady"
    end
end

-- ============================================================================
-- DECISION SYSTEM (combines Q-value + physics lookahead)
-- ============================================================================
local function decide(f, isMini)
    -- WAVE MODE GETS SPECIAL TREATMENT (smooth 45-degree movement)
    if STATE.mode == "wave" then
        return decideWave(f, isMini)
    end
    
    -- BALL MODE (gravity flip - don't spam)
    if STATE.mode == "ball" then
        return decideBall(f, isMini)
    end
    
    -- ROBOT MODE (hold to jump - longer hold = higher jump)
    if STATE.mode == "robot" then
        if f.pathInfo and f.pathInfo.hasFakePath then
            local recommended = f.pathInfo.recommendedPath
            if recommended then
                if f.py < recommended.yMin and not STATE.robotIsHolding then
                    STATE.robotTargetHoldDuration = 8
                    STATE.robotIsHolding = true
                    STATE.robotHoldStart = STATE.frame
                    return 1, nil, string.format("robot_path_to_%s", recommended.name)
                elseif f.py > recommended.yMax then
                    if STATE.robotIsHolding then
                        STATE.robotIsHolding = false
                        return 0, nil, "robot_path_release"
                    end
                    return 0, nil, string.format("robot_path_stay_%s", recommended.name)
                end
            end
        end
        
        if STATE.robotIsHolding then
            local holdDuration = STATE.frame - STATE.robotHoldStart
            if holdDuration >= STATE.robotTargetHoldDuration or f.minD < 1.5 then
                STATE.robotIsHolding = false
                return 0, nil, string.format("robot_release (held %d frames)", holdDuration)
            else
                return 1, nil, "robot_holding"
            end
        else
            if #f.obs > 0 and f.obs[1].dx < 7 and f.obs[1].dx > 0 then
                local dx = f.obs[1].dx
                local dy = f.obs[1].dy
                local gridDist = math.floor(dx / CFG.GRID_SIZE * 30)
                
                local targetGrids = math.min(5, math.max(1, gridDist))
                if dy > 3.0 then targetGrids = 5
                elseif dy > 2.5 then targetGrids = math.max(targetGrids, 4)
                elseif dy > 2.0 then targetGrids = math.max(targetGrids, 3)
                elseif dy > 1.2 then targetGrids = math.max(targetGrids, 2)
                end
                
                local targetDuration = CFG.ROBOT_JUMP_MAP[targetGrids] or 5
                
                STATE.robotTargetHoldDuration = targetDuration
                STATE.robotIsHolding = true
                STATE.robotHoldStart = STATE.frame
                return 1, nil, string.format("robot_start_hold (%d blocks = %d frames)", targetGrids, targetDuration)
            end
            return 0, nil, "robot_grounded"
        end
    end
    
    -- CUBE MODE - INTELLIGENT MULTI-JUMP for consecutive spikes
    if STATE.mode == "cube" then
        local framesSinceLastJump = STATE.frame - STATE.cubeLastJumpFrame
        
        local onPlatform = findPlatformBelowCube(f.px, f.py)
        local canJump = onPlatform ~= nil or f.py < 3.0
        
        if f.pathInfo and f.pathInfo.hasFakePath then
            local recommended = f.pathInfo.recommendedPath
            if recommended then
                if f.py < recommended.yMin then
                    if canJump and framesSinceLastJump > 10 then
                        STATE.cubeLastJumpFrame = STATE.frame
                        return 1, nil, string.format("cube_path_up_to_%s", recommended.name)
                    end
                elseif f.py > recommended.yMax then
                    return 0, nil, string.format("cube_path_stay_for_%s", recommended.name)
                end
            end
        end
        
        local nearestOrb = nil
        local minOrbDist = 999
        for _, orb in ipairs(STATE.orbs) do
            if orb.p and orb.p.Parent then
                local odx = orb.pos.X - f.px
                if odx > -0.5 and odx < 2.5 then
                    local ody = math.abs(orb.pos.Y - f.py)
                    if ody < 1.5 and odx < minOrbDist then
                        minOrbDist = odx
                        nearestOrb = orb
                    end
                end
            end
        end
        
        if nearestOrb and minOrbDist < 1.5 then
            if nearestOrb.orbType == "jump" or nearestOrb.orbType == "dash" or nearestOrb.orbType == "dash_gravity" then
                STATE.cubeLastJumpFrame = STATE.frame
                return 1, nil, string.format("cube_buffer_orb_%s (%.1fu)", nearestOrb.name, minOrbDist)
            elseif nearestOrb.orbType == "gravity" then
                STATE.cubeLastJumpFrame = STATE.frame
                return 1, nil, string.format("cube_buffer_gravity (%.1fu)", minOrbDist)
            elseif nearestOrb.orbType == "teleport" then
                STATE.cubeLastJumpFrame = STATE.frame
                return 1, nil, string.format("cube_buffer_spider (%.1fu)", minOrbDist)
            end
        end
        
        if f.multiJumpPlan then
            local plan = f.multiJumpPlan
            
            if plan.impossible then
                return 0, nil, string.format("cube_impossible (%d spikes, need pad/orb)", plan.spikeCount)
            end
            
            if plan.usePad or plan.useOrb then
                local nearestGroup = countConsecutiveSpikes(f.px)[1]
                if nearestGroup then
                    local firstSpikeX = nearestGroup[1].pos.X
                    local distToSpikes = firstSpikeX - f.px
                    if distToSpikes <= plan.jumpDistance + 0.3 and distToSpikes >= plan.jumpDistance - 0.3 and framesSinceLastJump > 10 and canJump then
                        STATE.cubeLastJumpFrame = STATE.frame
                        if plan.usePad then
                            return 1, nil, "cube_jump_with_pad"
                        else
                            return 1, nil, "cube_jump_to_orb"
                        end
                    end
                end
            elseif plan.lastFrame then
                local nearestGroup = countConsecutiveSpikes(f.px)[1]
                if nearestGroup then
                    local firstSpikeX = nearestGroup[1].pos.X
                    local distToSpikes = firstSpikeX - f.px
                    if distToSpikes <= plan.jumpDistance + 0.2 and distToSpikes >= plan.jumpDistance - 0.2 and framesSinceLastJump > 10 and canJump then
                        STATE.cubeLastJumpFrame = STATE.frame
                        return 1, nil, "cube_4spike_attempt"
                    end
                end
            else
                local nearestGroup = countConsecutiveSpikes(f.px)[1]
                if nearestGroup then
                    local firstSpikeX = nearestGroup[1].pos.X
                    local distToSpikes = firstSpikeX - f.px
                    
                    if distToSpikes <= plan.jumpDistance + 0.2 and distToSpikes >= plan.jumpDistance - 0.2 and framesSinceLastJump > 10 and canJump then
                        STATE.cubeLastJumpFrame = STATE.frame
                        return 1, nil, string.format("cube_jump_%dspikes (%.1f units)", plan.spikeCount, distToSpikes)
                    end
                end
            end
        else
            if #f.obs > 0 and f.obs[1].dx < 3.5 and f.obs[1].dx > 0.5 and framesSinceLastJump > 12 and canJump then
                STATE.cubeLastJumpFrame = STATE.frame
                return 1, nil, "cube_basic_jump"
            end
        end
        
        return 0, nil, "cube_grounded"
    end
    
    local s = stateKey(f, isMini)
    
    if f.pathInfo and f.pathInfo.hasFakePath and (STATE.mode == "ship" or STATE.mode == "ufo") then
        local recommended = f.pathInfo.recommendedPath
        if recommended then
            if f.py < recommended.yMin - 0.5 then
                return 1, s, string.format("%s_path_up_to_%s", STATE.mode, recommended.name)
            elseif f.py > recommended.yMax + 0.5 then
                return 0, s, string.format("%s_path_down_to_%s", STATE.mode, recommended.name)
            end
        end
    end
    
    if AI_BRAIN.enabled and #f.obs > 0 then
        local aiAction, aiConf, aiReason = getAIDecision(f, isMini)
        if aiAction and aiConf > 0.8 then
            return aiAction, s, aiReason
        end
    end
    
    -- CLICK PATTERN LEARNING SECOND - Use proven successful patterns
    local patternAction, patternConf, patternReason = getSuggestedAction(STATE.frame, STATE.lastA or 0)
    if patternAction and patternConf > 0.7 then
        return patternAction, s, patternReason
    end
    
    -- MATHEMATICAL OPTIMIZATION THIRD - but only when close enough
    -- Grid is 30x30: 4 spikes = 4 units. Don't react too early!
    if #f.obs > 0 then
        local nearestHazard = nil
        for _, h in ipairs(STATE.hazards) do
            if h.p and h.p.Parent then
                local dx = h.pos.X - f.px
                -- Only consider hazards that are actually close (3-4 units on 30x30 grid)
                if dx > 0 and dx < 4 then
                    nearestHazard = h
                    break
                end
            end
        end
        
        if nearestHazard then
            local mathSolution = calculateOptimalJump(f.px, f.py, f.vx, f.vy, nearestHazard, STATE.mode, isMini)
            -- TRUST MATH MORE - lowered threshold from 0.85 to 0.7
            if mathSolution and mathSolution.confidence > 0.7 then
                return mathSolution.action, s, mathSolution.reason
            end
        end
    end
    
    -- Physics evaluation - only when hazards are close
    if f.minD > 3.5 then
        -- Too far to worry, use Q-learning
        local s = stateKey(f, isMini)
        if math.random() < STATE.eps then
            return math.random() < 0.5 and 0 or 1, s, "explore"
        else
            local q0 = getQ(s, 0)
            local q1 = getQ(s, 1)
            return q1 > q0 and 1 or 0, s, "q_learning"
        end
    end
    
    local pos = Vector3.new(f.px, f.py, 0)
    local vel = Vector3.new(f.vx, f.vy, 0)
    
    local traj0 = predictPath(pos, vel, 0, STATE.mode, CFG.LOOKAHEAD, isMini)
    local traj1 = predictPath(pos, vel, 1, STATE.mode, CFG.LOOKAHEAD, isMini)
    
    local score0 = trajCollides(traj0, STATE.hazards) and -100 or 10
    local score1 = trajCollides(traj1, STATE.hazards) and -100 or 10
    
    -- Safe zone bonus (adjusted for mini mode)
    local minY = isMini and 1 or 2
    local maxY = isMini and 7 or 9
    for _, p in ipairs(traj0) do
        if p.p.Y > minY and p.p.Y < maxY then score0 = score0 + 0.3 end
    end
    for _, p in ipairs(traj1) do
        if p.p.Y > minY and p.p.Y < maxY then score1 = score1 + 0.3 end
    end
    
    -- Urgency based on distance (30x30 grid: be more cautious)
    local urgency = 0.5 -- Default: trust Q-learning
    if f.minD < 2.5 then
        urgency = 0.85 -- Very close, trust physics!
    elseif f.minD < 3.5 then
        urgency = 0.7 -- Close, mostly physics
    end
    
    -- Combine with Q-values
    local q0 = getQ(s, 0) * (1 - urgency) + score0 * urgency
    local q1 = getQ(s, 1) * (1 - urgency) + score1 * urgency
    
    -- Emergency override only when VERY close
    local a
    if f.minD < 1.5 then
        -- Emergency! Trust physics completely
        a = score1 > score0 and 1 or 0
    elseif math.random() < STATE.eps then
        a = math.random() < 0.5 and 0 or 1
    else
        a = q1 > q0 and 1 or 0
    end
    
    return a, s, "hybrid"
end

-- ============================================================================
-- REWARD CALCULATOR
-- ============================================================================
local function calcReward(event, f, prevF)
    local r = 0
    
    if event == "alive" then
        r = CFG.R_ALIVE
        
        -- Position rewards
        if f.py > 2 and f.py < 9 then r = r + 0.05 end
        if f.minD > 2.5 then r = r + 0.1 end
        if f.minD < 1.2 and f.minD > 0.5 then r = r + CFG.R_CLOSE end
        
        -- Progress reward: moving forward
        if f.px > STATE.lastX then
            local progress = (f.px - STATE.lastX) / CFG.GRID_SIZE
            r = r + CFG.R_PROGRESS * progress
            STATE.lastX = f.px
            if f.px > STATE.maxX then
                STATE.maxX = f.px
                r = r + 0.5 -- bonus for new record
            end
        end
        
        -- Smooth movement
        if prevF and math.abs(f.vy - prevF.vy) < 6 then r = r + 0.06 end
        
    elseif event == "pass" then
        r = CFG.R_PASS
        
    elseif event == "death" then
        r = CFG.R_DEATH
        -- Less harsh if made progress
        local progress = STATE.lastX / math.max(1, STATE.maxX)
        if progress > 0.5 then
            r = r * 0.7 -- reduce penalty if got far
        end
    end
    
    return r
end

-- ============================================================================
-- ACTION EXECUTOR (using input like ControlModule)
-- ============================================================================
local holding = false

local function exec(a, mode)
    if mode == "cube" then
        if a == 1 then
            keypress(Enum.KeyCode.Space)
            task.wait(0.06)
            keyrelease(Enum.KeyCode.Space)
        end
    elseif mode == "ship" or mode == "wave" then
        if a == 1 and not holding then
            keypress(Enum.KeyCode.Space)
            holding = true
        elseif a == 0 and holding then
            keyrelease(Enum.KeyCode.Space)
            holding = false
        end
    elseif mode == "ufo" then
        if a == 1 then
            keypress(Enum.KeyCode.Space)
            task.wait(0.04)
            keyrelease(Enum.KeyCode.Space)
        end
    elseif mode == "ball" then
        if a == 1 then
            keypress(Enum.KeyCode.MouseButton1)
            task.wait(0.04)
            keyrelease(Enum.KeyCode.MouseButton1)
        end
    end
end

-- ============================================================================
-- COLLISION (AABB from camera occlusion pattern)
-- ============================================================================
local function checkCol()
    local px, py, pz = plr.Position.X, plr.Position.Y, plr.Position.Z
    local playerSize = STATE.mini and 0.35 or 0.5
    
    for _, h in ipairs(STATE.hazards) do
        if h.p and h.p.Parent then
            local hx, hy, hz = h.pos.X, h.pos.Y, h.pos.Z
            local sx, sy, sz = h.sz.X, h.sz.Y, h.sz.Z
            
            if math.abs(px-hx) <= (playerSize+sx/2) and 
               math.abs(py-hy) <= (playerSize+sy/2) and 
               math.abs(pz-hz) <= (playerSize+sz/2) then
                return true
            end
        end
    end
    return false
end

-- ============================================================================
-- DEATH HANDLER
-- ============================================================================
local function onDeath()
    STATE.alive = false
    STATE.deaths = STATE.deaths + 1
    
    -- Save failed click pattern
    saveFailedPattern()
    
    if STATE.lastS and STATE.lastA then
        local r = calcReward("death", STATE.lastF)
        addReplay(STATE.lastS, STATE.lastA, r, STATE.lastS, true)
        STATE.totalR = STATE.totalR + r
    end
    
    -- Decay epsilon faster if not making progress
    local progressRate = STATE.lastX / math.max(1, STATE.maxX)
    if progressRate < 0.3 and STATE.deaths > 10 then
        -- Stuck early, decay faster
        STATE.eps = math.max(STATE.eps * 0.995, CFG.EPS_MIN)
    else
        STATE.eps = math.max(STATE.eps * CFG.EPS_DECAY, CFG.EPS_MIN)
    end
    
    -- Learn EXTREMELY intensively
    for i = 1, 25 do learnBatch() end
    
    -- Show pattern stats
    local patternInfo = ""
    if #CLICK_PATTERNS.successful > 0 then
        patternInfo = string.format(" | Patterns:%d", #CLICK_PATTERNS.successful)
    end
    
    print(string.format("[D:%d]%s Eps:%.3f | MaxX:%.1f | Pass:%d | Method:%s%s", 
        STATE.deaths, STATE.mini and " MINI" or "", STATE.eps, STATE.maxX, STATE.passes, STATE.lastMethod or "unknown", patternInfo))
    
    -- Reset per-attempt state
    STATE.lastS = nil
    STATE.lastA = nil
    STATE.lastF = nil
    STATE.lastX = 0
    CLICK_PATTERNS.current = {} -- Reset pattern
    
    -- Reset mode-specific state
    STATE.waveHoldState = 0
    STATE.waveLastDecisionFrame = 0
    STATE.robotIsHolding = false
    STATE.robotHoldStart = 0
    STATE.ballLastFlipFrame = 0
    STATE.cubeLastJumpFrame = 0
    STATE.multiJumpPlan = {}
    STATE.multiJumpIndex = 0
    
    task.wait(0.5)
    STATE.alive = true
end

-- ============================================================================
-- MAIN LOOP (using RenderStep pattern like ControlModule)
-- ============================================================================

print("üöÄ ULTRA BOT INITIALIZED - AI REASONING EDITION v4.0")
print("ü§ñ AI REASONING: Claude Sonnet 4.5 (ENABLED)")
print("   Bot will think out loud and explain decisions")
print("üß† Click Pattern Learning: ENABLED")
print("üìö Parts Database Loaded:")
print(string.format("   - %d InstantDeath patterns (kills all modes)", #PARTS_DB.InstantDeath))
print(string.format("   - %d DangerToWave patterns (wave must avoid)", #PARTS_DB.DangerToWave))
print("üßÆ Mathematical Jump Optimization: ENABLED")
print("üîΩ Mini Mode Support: ENABLED")
print("üéØ Decision Priority:")
print("   1. AI Reasoning (Claude Sonnet 4.5 analyzes situation)")
print("   2. Learned click patterns (from successful runs)")
print("   3. Mathematical optimization (physics-based)")
print("   4. Q-learning with physics urgency")
print("üîç Detection System:")
print("   - Parts database pattern matching")
print("   - Mode-aware hazard classification")
print("   - Color-based fallback detection")
print("   - Wave detects ALL solid obstacles")

-- Detect initial mode
STATE.mode = detectMode()
print(string.format("üéÆ Initial mode detected: %s", STATE.mode))

STATE.hazards = scanHazards()
print(string.format("üìä Detected %d hazards for mode: %s", #STATE.hazards, STATE.mode))
if #STATE.hazards > 0 and STATE.hazards[1].name then
    print(string.format("üìù First hazard: %s (type: %s, threat: %.1f)", 
        STATE.hazards[1].name, STATE.hazards[1].htype or "unknown", STATE.hazards[1].t))
end

STATE.pads = scanPads()
print(string.format("üéØ Detected %d jump pads", #STATE.pads))
if #STATE.pads > 0 then
    print(string.format("   First pad: %s (boost: %.1fx)", STATE.pads[1].padType, STATE.pads[1].boost))
end

STATE.orbs = scanOrbs()
print(string.format("üíé Detected %d orbs", #STATE.orbs))
if #STATE.orbs > 0 then
    print(string.format("   First orb: %s (%s)", STATE.orbs[1].name, STATE.orbs[1].orbType))
end

print("\nüí≠ Watch for AI thoughts in console (marked with üß†)")

-- Auto-save stats
task.spawn(function()
    while true do
        task.wait(180)
        print(string.format("üíæ [SAVE] D:%d P:%d AvgR:%.3f Eps:%.4f QSize:%d",
            STATE.deaths, STATE.passes, 
            STATE.totalR / math.max(1, STATE.frame),
            STATE.eps,
            #STATE.replay))
    end
end)

-- Main game loop (RenderStep pattern)
RunService.Heartbeat:Connect(function(dt)
    if not STATE.alive then return end
    
    STATE.frame = STATE.frame + 1
    
    -- Detect mode changes (important for wave mode which sees different hazards)
    local currentMode = STATE.mode
    local newMode = detectMode() -- Need to detect mode each frame
    if newMode ~= currentMode then
        STATE.mode = newMode
        print(string.format("üîÑ Mode changed: %s -> %s (rescanning hazards)", currentMode, newMode))
        STATE.hazards = scanHazards()
        STATE.pads = scanPads()
        STATE.orbs = scanOrbs()
        print(string.format("   Detected %d hazards, %d pads, %d orbs for %s mode", #STATE.hazards, #STATE.pads, #STATE.orbs, newMode))
        
        -- Reset all mode-specific states
        STATE.waveHoldState = 0
        STATE.waveLastDecisionFrame = 0
        STATE.robotIsHolding = false
        STATE.robotHoldStart = 0
        STATE.ballLastFlipFrame = 0
        STATE.cubeLastJumpFrame = 0
        STATE.multiJumpPlan = {}
        STATE.multiJumpIndex = 0
    end
    
    -- Rescan hazards and pads periodically (but more often in wave mode)
    local rescanInterval = (STATE.mode == "wave") and 15 or 30
    if STATE.frame % rescanInterval == 0 then
        STATE.hazards = scanHazards()
        STATE.pads = scanPads()
        STATE.orbs = scanOrbs()
    end
    
    -- Detect mini mode
    STATE.mini = detectMiniMode()
    
    -- Extract features
    local px, py = plr.Position.X, plr.Position.Y
    local vx, vy = plr.AssemblyLinearVelocity.X, plr.AssemblyLinearVelocity.Y
    local f = extractFeats(px, py, vx, vy)
    
    -- Make decision
    local a, s, method = decide(f, STATE.mini)
    
    -- Track decision methods for debugging
    if STATE.frame % 100 == 0 and method then
        STATE.lastMethod = method
    end
    
    -- Execute
    exec(a, STATE.mode)
    
    -- Record click for pattern learning
    recordClick(a, STATE.frame)
    
    -- Check collision
    if checkCol() then
        onDeath()
        return
    end
    
    -- Check passed hazards
    for _, h in ipairs(STATE.hazards) do
        if h.p and h.p.Parent then
            local hid = h.p:GetDebugId()
            if not STATE.passed[hid] and px > h.pos.X + h.sz.X/2 + 1 then
                STATE.passed[hid] = true
                STATE.passes = STATE.passes + 1
                
                -- Save successful pattern when passing obstacle
                if STATE.passes % 5 == 0 then
                    saveSuccessfulPattern()
                end
                
                if STATE.lastS and STATE.lastA then
                    local r = calcReward("pass", f, STATE.lastF)
                    addReplay(STATE.lastS, STATE.lastA, r, s, false)
                    STATE.totalR = STATE.totalR + r
                end
            end
        end
    end
    
    -- Alive reward
    if STATE.lastS and STATE.lastA then
        local r = calcReward("alive", f, STATE.lastF)
        addReplay(STATE.lastS, STATE.lastA, r, s, false)
        STATE.totalR = STATE.totalR + r
    end
    
    -- Learn CONSTANTLY
    if STATE.frame % 3 == 0 then
        learnBatch()
    end
    
    -- Update for next iteration
    STATE.lastS = s
    STATE.lastA = a
    STATE.lastF = f
    
    -- Stats
    if STATE.frame % 500 == 0 then
        local progress = (STATE.lastX / math.max(1, STATE.maxX)) * 100
        local mathUsage = STATE.lastMethod and (STATE.lastMethod:find("math") and "üßÆ" or "ü§ñ") or "‚ùì"
        local miniIcon = STATE.mini and "üîΩ" or "üîº"
        print(string.format("üìà %s%s F:%d D:%d P:%d MaxX:%.1f E:%.3f",
            mathUsage, miniIcon, STATE.frame, STATE.deaths, STATE.passes, STATE.maxX, STATE.eps))
    end
end)

-- Debug commands
_G.stats = function()
    print("=== BOT STATS ===")
    print("Mode:", STATE.mode, STATE.mini and "(MINI)" or "(NORMAL)")
    print("Deaths:", STATE.deaths)
    print("Passes:", STATE.passes)
    print("Max Progress:", STATE.maxX)
    print("Avg Reward:", STATE.totalR / math.max(1, STATE.frame))
    print("Epsilon:", STATE.eps)
    print("Replay Buffer:", #STATE.replay)
    print("Learning Rate:", CFG.LR)
    print("Last Method:", STATE.lastMethod)
    print("Hazards Detected:", #STATE.hazards)
    print("\n=== AI BRAIN ===")
    print("AI Enabled:", AI_BRAIN.enabled and "YES" or "NO")
    print("AI Thoughts:", #AI_BRAIN.thoughts)
    print("Last Thought:", AI_BRAIN.lastThought or "None")
    print("Think Interval:", AI_BRAIN.thinkInterval, "frames")
    print("\n=== PATTERNS ===")
    print("Successful:", #CLICK_PATTERNS.successful)
    print("Failed:", #CLICK_PATTERNS.failed)
end

_G.boost = function()
    print("üöÄ BOOSTING LEARNING")
    CFG.LR = 0.5
    CFG.BATCH = 96
    STATE.eps = 0.3
    print("LR -> 0.5, Batch -> 96, Eps -> 0.3")
end

_G.ultraMode = function()
    print("‚ö° ULTRA AGGRESSIVE MODE ACTIVATED")
    CFG.LR = 0.75
    CFG.BATCH = 120
    CFG.EPS_DECAY = 0.995
    STATE.eps = 0.7
    CFG.R_PASS = 20.0
    CFG.R_DEATH = -4.0
    print("LR -> 0.75, Batch -> 120, Eps -> 0.7")
    print("Pass reward -> 20, Death penalty -> -4")
    print("This will make it learn VERY fast but might be unstable")
end

_G.mathInfo = function()
    print("=== MATH OPTIMIZATION ===")
    print("Normal Physics:")
    print("  Cube Jump:", PHYS.cube_jump)
    print("  Ship Up:", PHYS.ship_up)
    print("  UFO Jump:", PHYS.ufo_jump)
    print("  Wave Up:", PHYS.wave_up)
    print("  Gravity:", PHYS.grav)
    print("Mini Mode Physics:")
    print("  Cube Jump:", PHYS.mini_cube_jump)
    print("  Ship Up:", PHYS.mini_ship_up)
    print("  UFO Jump:", PHYS.mini_ufo_jump)
    print("  Wave Up:", PHYS.mini_wave_up)
    print("  Gravity:", PHYS.mini_grav)
    print("Detection: RegularSpike## + Really black")
    print("Lookahead Steps:", CFG.LOOKAHEAD)
    print("Current Mode:", STATE.mini and "MINI" or "NORMAL")
end

_G.listHazards = function(count)
    count = count or 10
    print(string.format("=== HAZARDS (mode: %s, showing %d) ===", STATE.mode, math.min(count, #STATE.hazards)))
    for i = 1, math.min(count, #STATE.hazards) do
        local h = STATE.hazards[i]
        if h.p and h.p.Parent then
            print(string.format("%d. %s @ X:%.1f Y:%.1f | Type:%s Threat:%.1f", 
                i, h.name or "Unknown", h.pos.X, h.pos.Y, h.htype or "unknown", h.t))
        end
    end
    print(string.format("Total: %d hazards detected", #STATE.hazards))
    
    -- Show breakdown by type
    local typeCount = {}
    for _, h in ipairs(STATE.hazards) do
        local t = h.htype or "unknown"
        typeCount[t] = (typeCount[t] or 0) + 1
    end
    print("Breakdown:")
    for htype, count in pairs(typeCount) do
        print(string.format("  %s: %d", htype, count))
    end
end

_G.showDatabase = function()
    print("=== PARTS DATABASE ===")
    print("\nINSTANT DEATH (kills all modes):")
    for i, pattern in ipairs(PARTS_DB.InstantDeath) do
        print(string.format("  %d. %s", i, pattern))
    end
    print(string.format("\nDANGER TO WAVE (wave must avoid):"))
    for i, pattern in ipairs(PARTS_DB.DangerToWave) do
        print(string.format("  %d. %s", i, pattern))
    end
    print(string.format("\nTotal patterns: %d", #PARTS_DB.InstantDeath + #PARTS_DB.DangerToWave))
end

_G.showPatterns = function()
    print("=== CLICK PATTERN LEARNING ===")
    print(string.format("Successful patterns: %d", #CLICK_PATTERNS.successful))
    print(string.format("Failed patterns: %d", #CLICK_PATTERNS.failed))
    print(string.format("Current pattern length: %d", #CLICK_PATTERNS.current))
    
    if #CLICK_PATTERNS.successful > 0 then
        print("\nTop 5 successful patterns:")
        for i = 1, math.min(5, #CLICK_PATTERNS.successful) do
            local p = CLICK_PATTERNS.successful[i]
            print(string.format("  %d. Score:%.2f | Clicks:%d | AvgClick:%.1ff AvgRelease:%.1ff", 
                i, p.score, #p.clicks, p.avgClickDuration, p.avgReleaseDuration))
        end
    end
    
    if #CLICK_PATTERNS.failed > 0 then
        print(string.format("\nLast failed pattern: %d actions", #CLICK_PATTERNS.failed[#CLICK_PATTERNS.failed].lastActions))
    end
end

_G.toggleAI = function()
    AI_BRAIN.enabled = not AI_BRAIN.enabled
    print(string.format("ü§ñ AI Reasoning: %s", AI_BRAIN.enabled and "ENABLED" or "DISABLED"))
    if AI_BRAIN.enabled then
        print("   Bot will use Claude Sonnet 4.5 to make intelligent decisions")
    else
        print("   Bot will use patterns + math + Q-learning only")
    end
end

_G.showThoughts = function()
    print("=== AI RECENT THOUGHTS ===")
    print(string.format("AI Enabled: %s", AI_BRAIN.enabled and "YES" or "NO"))
    print(string.format("Last thought: %s", AI_BRAIN.lastThought or "None yet"))
    print(string.format("Total thoughts: %d", #AI_BRAIN.thoughts))
    
    if #AI_BRAIN.thoughts > 0 then
        print("\nRecent thoughts (last 10):")
        local start = math.max(1, #AI_BRAIN.thoughts - 9)
        for i = start, #AI_BRAIN.thoughts do
            local t = AI_BRAIN.thoughts[i]
            local actionText = t.action == 1 and "JUMP" or "STAY"
            print(string.format("  Frame %d [%s]: %s", t.frame, actionText, t.thought))
        end
    end
end

_G.setAISpeed = function(interval)
    AI_BRAIN.thinkInterval = interval or 5
    print(string.format("ü§ñ AI think interval set to %d frames", AI_BRAIN.thinkInterval))
    print("   Lower = more AI decisions (slower but smarter)")
    print("   Higher = fewer AI decisions (faster but less intelligent)")
end

print("‚úÖ Bot running! Commands:")
print("  _G.stats() - view stats")
print("  _G.showThoughts() - see what AI is thinking")
print("  _G.toggleAI() - enable/disable AI reasoning")
print("  _G.setAISpeed(n) - set AI think interval (default 5 frames)")
print("  _G.showPatterns() - show click pattern learning stats")
print("  _G.listHazards(n) - show detected hazards")
print("  _G.showDatabase() - show parts knowledge database")
print("  _G.boost() - boost learning")
print("  _G.ultraMode() - ULTRA aggressive mode")
print("  _G.mathInfo() - math optimization info")
